---
title: "ARAVO"
author: "Apolline Saint-Pierre"
date: "2025-09-27"
output: html_document
---

```{r}

library(readxl)
REL2001 <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "REL2001")
View(REL2001)
library(readxl)
REL2022 <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "REL2022")
View(REL2022)
library(readxl)
META <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "META")
View(META)
```



```{r}
rel2001 = REL2001
rel2022 = REL2022
meta = META
rel2001
```

## R Markdown


```{r}
# Charger les packages
library(readxl)
library(dplyr)
library(vegan)
library(cluster)
```


```{r}
# Filtrer les ID comparables : yes/yes dans meta
valid_ids <- meta %>%
  filter(DATA_2001 == "yes" & DATA_2022 == "yes") %>%
  pull(ID)

rel2001 <- rel2001 %>% filter(ID %in% valid_ids)
rel2022 <- rel2022 %>% filter(ID %in% valid_ids)
```


```{r}
# Ajouter une colonne "Year"
rel2001$Year <- 2001
rel2022$Year <- 2022
```

```{r}
# Supprimer les colonnes non pertinentes (sommes, completed...)
rel2001_clean <- rel2001 %>%
  select(-SOMME)

rel2022_clean <- rel2022 %>%
  select(-contains("COMPLETED"), -HABITAT)
```

```{r}
# Harmoniser les noms des colonnes esp√®ces
common_species <- intersect(names(rel2001_clean), names(rel2022_clean))
meta_cols <- c("ROW","COL","ID","Year")
species_cols <- setdiff(common_species, meta_cols)

rel2001_clean <- rel2001_clean %>% select(all_of(meta_cols), all_of(species_cols))
rel2022_clean <- rel2022_clean %>% select(all_of(meta_cols), all_of(species_cols))

```


```{r}
# S'assurer que toutes les colonnes esp√®ces sont du m√™me type (numeric)
for (col in species_cols) {
  rel2001_clean[[col]] <- as.numeric(rel2001_clean[[col]])
  rel2022_clean[[col]] <- as.numeric(rel2022_clean[[col]])
}

# Supprimer les lignes contenant des NA
rel2001_clean <- rel2001_clean %>% drop_na(all_of(species_cols))
rel2022_clean <- rel2022_clean %>% drop_na(all_of(species_cols))


# Fusionner les deux jeux
all_data <- bind_rows(rel2001_clean, rel2022_clean)
all_data
```

```{r}

# Supprimer la colonne "Sol nu" si elle existe

if("Sol nu" %in% names(all_data)) {
  all_data <- all_data %>% select(-`Sol nu`)
}

# Mettre √† jour la liste des colonnes esp√®ces
species_cols_filtered <- setdiff(species_cols, "Sol nu")

# Supprimer les lignes o√π aucune esp√®ce restante n'est pr√©sente
all_data <- all_data %>% filter(rowSums(select(., all_of(species_cols_filtered))) > 0)

# Supprimer les lignes contenant des NA (s√©curit√©)
all_data <- all_data %>% drop_na(all_of(species_cols_filtered))

# Identifier ID communes
common_IDs <- intersect(rel2001_clean$ID, rel2022_clean$ID)

# Filtrer les deux jeux pour ne garder que les ID communes
rel2001_common <- rel2001_clean %>% filter(ID %in% common_IDs)
rel2022_common <- rel2022_clean %>% filter(ID %in% common_IDs)

# Fusionner
all_data_common <- bind_rows(rel2001_common, rel2022_common)

# Supprimer les NA par s√©curit√©
all_data_common <- all_data_common %>% drop_na(all_of(species_cols_filtered))
```


```{r}
all_data_common
```

```{r}

# Supprimer lignes vides
all_data_common_clean <- all_data_common %>%
  filter(rowSums(select(., all_of(species_cols_filtered))) > 0)

# --- 2. Matrice pr√©sence/absence ---
comm_matrix <- as.matrix(all_data_common_clean[, species_cols_filtered])
comm_matrix_bin <- (comm_matrix > 0) * 1


# Garder les IDs correspondant aux lignes conserv√©es
keep_rows <- rowSums(comm_matrix_bin) > 0
comm_matrix_bin <- comm_matrix_bin[keep_rows, ]
final_IDs <- all_data_common_clean$ID[keep_rows]
years <- all_data_common_clean$Year[keep_rows]

# --- 3. Calcul de la distance Jaccard ---
dist_jac <- vegdist(comm_matrix_bin, method = "jaccard")

# --- 4. Clustering hi√©rarchique ---
clust <- hclust(dist_jac, method = "ward.D2")

# Visualisation rapide
plot(clust, labels = final_IDs, main = "Dendrogramme Jaccard", hang = -1, cex = 0.8)
```
```{r}
# --- 5. Choix du nombre de clusters avec silhouette ---
k_max <- 10
sil_scores <- sapply(2:k_max, function(k) {
  cluster_assign <- cutree(clust, k)
  silhouette(cluster_assign, dist_jac) %>% summary() %>% .$avg.width
})
best_k <- which.max(sil_scores) + 1
cat("Nombre optimal de clusters selon silhouette :", best_k, "\n")

```

```{r}
# D√©couper l'arbre
cluster_assign <- cutree(clust, k = best_k)

# --- 6. Ajouter les clusters √† la table ---
all_data_common_clean <- all_data_common_clean[keep_rows, ]  # filtrer les lignes correspondant √† comm_matrix_bin
all_data_common_clean$Cluster <- cluster_assign
all_data_common_clean

``{r}
library(writexl)

# Exporter la table finale en Excel dans ton dossier ARAVO
write_xlsx(all_data_common_clean, path = "all_data_common_clean.xlsx")


```

```{r}
# --- 7. Joindre les coordonn√©es Lambert 93 depuis meta ---
# meta doit contenir : ID, X_L93, Y_L93
final_table <- all_data_common_clean %>%
  left_join(meta %>% select(ID, X_L93, Y_L93), by = "ID") %>%
  select(ID, Year, X_L93, Y_L93, Cluster)
```




```{r}
# --- 7. Joindre les coordonn√©es Lambert 93 depuis meta ---
# meta doit contenir : ID, X_L93, Y_L93
final_salix_herb <- all_data_common_clean %>%
  left_join(meta %>% select(ID, X_L93, Y_L93), by = "ID") %>%
  select(ID, Year, X_L93, Y_L93, `Care myos`, `Sali herb`)
final_salix_herb

library(writexl)

# Exporter la table finale en Excel dans ton dossier ARAVO
write_xlsx(final_salix_herb, path = "final_salix_herb.xlsx")
```





```{r}
# V√©rifier le r√©sultat
head(final_table)
```
```{r}
final_table
```
```{r}
library(writexl)

# Exporter la table finale en Excel dans ton dossier ARAVO
write_xlsx(final_table, path = "final_table_clusters.xlsx")

# V√©rifier le r√©pertoire de travail (optionnel)
getwd()

```
```{r}
library(dplyr)
library(writexl)

# Calcul de la moyenne d'abondance (ou fr√©quence de pr√©sence) par cluster
species_by_cluster <- all_data_common_clean %>%
  group_by(Cluster) %>%
  summarise(across(all_of(species_cols_filtered), \(x) mean(x, na.rm = TRUE)))

```

```{r}
species_presence <- (species_by_cluster > 0) * 1
species_presence <- cbind(Cluster = species_by_cluster$Cluster, species_presence)
```

```{r}
write_xlsx(species_by_cluster, path = "species_by_cluster.xlsx")
```

```{r}
library(dplyr)
library(tidyr)
library(writexl)

# Calcul de la fr√©quence d'occurrence (% des placettes du cluster o√π l'esp√®ce est pr√©sente)
species_freq <- all_data_common_clean %>%
  group_by(Cluster) %>%
  summarise(across(all_of(species_cols_filtered),
                   \(x) 100 * sum(x > 0, na.rm = TRUE) / n()))
```

```{r}
species_freq_long <- species_freq %>%
  pivot_longer(
    -Cluster,
    names_to = "Espece",
    values_to = "Frequence"
  ) %>%
  arrange(Cluster, desc(Frequence))
```




```{r}
write_xlsx(species_freq_long, path = "species_frequence_by_cluster.xlsx")
```


```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

```


```{r}
species_freq_long <- species_freq %>%
  pivot_longer(
    -Cluster,
    names_to = "Espece",
    values_to = "Frequence"
  )
```

```{r}
ggplot(species_freq_long, aes(x = Espece, y = factor(Cluster), fill = Frequence)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "darkgreen", name = "Fr√©quence (%)") +
  labs(
    title = "Fr√©quence des esp√®ces par cluster",
    x = "Esp√®ces",
    y = "Clusters"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    panel.grid = element_blank()
  )
```

```{r}
top_species <- species_freq_long %>%
  group_by(Espece) %>%
  summarise(MaxFreq = max(Frequence)) %>%
  arrange(desc(MaxFreq)) %>%
  slice_head(n = 20) %>%
  pull(Espece)

species_freq_top <- species_freq_long %>%
  filter(Espece %in% top_species)

ggplot(species_freq_top, aes(x = Espece, y = factor(Cluster), fill = Frequence)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "darkgreen", name = "Fr√©quence (%)") +
  labs(
    title = "Top 20 esp√®ces les plus fr√©quentes par cluster",
    x = "Esp√®ces",
    y = "Clusters"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    panel.grid = element_blank()
  )
```




```{r}
# Filtrer les deux jeux pour ne garder que les ID communes
rel2001_common <- rel2001_clean %>% filter(ID %in% common_IDs)
rel2022_common <- rel2022_clean %>% filter(ID %in% common_IDs)

rel2001_common

```


```{r}
rel2022_common
```



```{r}
# -----------------------------------------------------------
# ‚öôÔ∏è Chargement des librairies n√©cessaires
# -----------------------------------------------------------
library(ade4)
library(ggplot2)
library(dplyr)

# -----------------------------------------------------------
# üß≠ V√©rification de la correspondance des lignes
# -----------------------------------------------------------
# Les ID doivent √™tre dans le m√™me ordre
all(rownames(rel2001_common) == rownames(rel2022_common))
# Si FALSE ‚Üí r√©aligner :
# rel2022_common <- rel2022_common[match(rownames(rel2001_common), rownames(rel2022_common)), ]

# -----------------------------------------------------------
# üìä 1. ACP sur chaque tableau
# -----------------------------------------------------------
# S√©lectionne uniquement les colonnes num√©riques correspondant aux esp√®ces
rel2001_common_num <- rel2001_common %>% 
  dplyr::select(-ROW, -COL, -ID, -Year)

rel2022_common_num <- rel2022_common %>% 
  dplyr::select(-ROW, -COL, -ID, -Year)


rel2001_common_num[is.na(rel2001_common_num)] <- 0
rel2022_common_num[is.na(rel2022_common_num)] <- 0


library(ade4)
# ACP pour chaque ann√©e
pca2001 <- dudi.pca(rel2001_common_num, scannf = FALSE, nf = 3)
pca2022 <- dudi.pca(rel2022_common_num, scannf = FALSE, nf = 3)

# Co-inertie
coin <- coinertia(pca2001, pca2022, scannf = FALSE)

# R√©sum√© et graphique
summary(coin)
plot(coin)

# -----------------------------------------------------------
# üîó 2. Analyse de co-inertie
# -----------------------------------------------------------
coin <- coinertia(pca2001, pca2022, scannf = FALSE)

# R√©sum√© des r√©sultats
summary(coin)

```

```{r}
# -----------------------------------------------------------
# üìà 3. Visualisations principales
# -----------------------------------------------------------
# Inertie commune

???????
# -----------------------------------------------------------
# üß† 4. Interpr√©tation
# -----------------------------------------------------------
# Coefficient RV (corr√©lation globale entre structures)
RV <- RV.rtest(pca2001$tab, pca2022$tab)
RV
plot(RV)

# -----------------------------------------------------------
# üíæ 5. Sauvegarde des coordonn√©es si besoin
# -----------------------------------------------------------
coords <- as.data.frame(coin$ls)
coords$ID <- rownames(rel2001_common)
write.csv(coords, "co_inertia_coordinates.csv", row.names = FALSE)
```



# Ici la cr√©ation de la feuille pr√©cence et absence pour salix et carex 


```{r}
# Packages
library(tidyverse)

# On part de ton data.frame d√©j√† charg√©
df <- final_salix_herb

# Renommer pour simplifier
df <- df %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  )

# V√©rification
glimpse(df)
```

```{r}
# Table crois√©e de co-occurrence
tab <- table(df$Carex, df$Salix)
tab
```


```{r}
chisq.test(tab)
```
```{r}
fisher.test(tab)
```

```{r}
# Graphique de cooccurrence
df %>%
  count(Carex, Salix) %>%
  ggplot(aes(x = factor(Salix), y = factor(Carex), size = n, color = n)) +
  geom_point() +
  scale_size(range = c(3,10)) +
  theme_minimal() +
  labs(x = "Salix herbacea (0=abs, 1=pres)",
       y = "Carex myosuroides (0=abs, 1=pres)",
       title = "Co-occurrence des deux esp√®ces")
```


```{r}
ggplot(df, aes(x = X_L93, y = Y_L93, color = interaction(Carex, Salix))) +
  geom_point(size = 3) +
  scale_color_manual(values = c("grey50", "orange", "blue", "green"),
                     labels = c("Aucune", "Carex seule", "Salix seule", "Les deux")) +
  theme_minimal() +
  labs(title = "Distribution spatiale des co-occurrences",
       color = "Pr√©sence des esp√®ces")
```

```{r}
cor.test(df$Carex, df$Salix, method = "spearman")  # test de corr√©lation non param√©trique

```

```{r}
library(tidyverse)

df <- final_salix_herb %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  )

# V√©rification
unique(df$Year)

# ------------------------
# 2Ô∏è‚É£ Test de cooccurrence s√©par√© par ann√©e
# ------------------------

# --- Pour 2001 ---
df_2001 <- df %>% filter(Year == 2001)
tab_2001 <- table(df_2001$Carex, df_2001$Salix)
tab_2001

test_2001 <- fisher.test(tab_2001)
test_2001

# --- Pour 2022 ---
df_2022 <- df %>% filter(Year == 2022)
tab_2022 <- table(df_2022$Carex, df_2022$Salix)
tab_2022

test_2022 <- fisher.test(tab_2022)
test_2022

# ------------------------
# 3Ô∏è‚É£ R√©sum√© des r√©sultats
# ------------------------
results <- tibble(
  Year = c(2001, 2022),
  p_value = c(test_2001$p.value, test_2022$p.value),
  odds_ratio = c(test_2001$estimate, test_2022$estimate),
  CI_low = c(test_2001$conf.int[1], test_2022$conf.int[1]),
  CI_high = c(test_2001$conf.int[2], test_2022$conf.int[2])
)

print(results)
```

En 2001
L‚Äôodds ratio < 1 (0.63) sugg√®re une tendance √† l‚Äôexclusion,

üëâ mais pas significative statistiquement (p = 0.12).
Autrement dit, en 2001, Salix herbacea et Carex myosuroides pouvaient coexister dans certains plots, sans qu‚Äôon d√©tecte un sch√©ma clair d‚Äôexclusion ou d‚Äôassociation.

En 2022

L‚Äôodds ratio chute √† 0.21, et le test devient hautement significatif (p < 0.001).
Cela signifie qu‚Äôen 2022, les deux esp√®ces sont nettement moins souvent retrouv√©es ensemble qu‚Äôattendu al√©atoirement.
‚Üí Leur co-occurrence a diminu√© dans le temps.





```{r}
 1Ô∏è‚É£ Packages
# -------------------------------
library(tidyverse)
library(ggplot2)
library(patchwork)  # pour mettre deux cartes c√¥te √† c√¥te

# -------------------------------
# 2Ô∏è‚É£ Pr√©paration des donn√©es
# -------------------------------
df <- final_salix_herb %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  ) %>%
  mutate(
    combo = case_when(
      Carex == 1 & Salix == 1 ~ "Les deux",
      Carex == 1 & Salix == 0 ~ "Carex seule",
      Carex == 0 & Salix == 1 ~ "Salix seule",
      TRUE ~ "Aucune"
    )
  )

# -------------------------------
# 3Ô∏è‚É£ S√©parer les ann√©es
# -------------------------------
df_2001 <- df %>% filter(Year == 2001)
df_2022 <- df %>% filter(Year == 2022)

# -------------------------------
# 4Ô∏è‚É£ Cr√©er les cartes
# -------------------------------
carte_2001 <- ggplot(df_2001, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.8) +
  scale_color_manual(values = c("grey60", "orange", "blue", "green")) +
  theme_minimal() +
  coord_equal() +
  labs(title = "2001 - Distribution des esp√®ces",
       color = "Pr√©sence")

carte_2022 <- ggplot(df_2022, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.8) +
  scale_color_manual(values = c("grey60", "orange", "blue", "green")) +
  theme_minimal() +
  coord_equal() +
  labs(title = "2022 - Distribution des esp√®ces",
       color = "Pr√©sence")

# -------------------------------
# 5Ô∏è‚É£ Afficher c√¥te √† c√¥te
# -------------------------------
carte_2001 + carte_2022
```
```{r}
# -------------------------------
# 1Ô∏è‚É£ Packages n√©cessaires
# -------------------------------
library(tidyverse)
library(patchwork)  # pour combiner les cartes

# -------------------------------
# 2Ô∏è‚É£ Pr√©paration des donn√©es
# -------------------------------
df <- final_salix_herb %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  ) %>%
  mutate(
    combo = case_when(
      Carex == 1 & Salix == 1 ~ "Les deux esp√®ces",
      Carex == 1 & Salix == 0 ~ "Carex seule",
      Carex == 0 & Salix == 1 ~ "Salix seule",
      TRUE ~ "Aucune des deux"
    )
  )

# -------------------------------
# 3Ô∏è‚É£ S√©parer les ann√©es
# -------------------------------
df_2001 <- df %>% filter(Year == 2001)
df_2022 <- df %>% filter(Year == 2022)

# -------------------------------
# 4Ô∏è‚É£ D√©finir les couleurs et le th√®me
# -------------------------------
couleurs <- c(
  "Aucune des deux" = "grey70",
  "Carex seule" = "#E69F00",  # orange
  "Salix seule" = "#0072B2",  # bleu
  "Les deux esp√®ces" = "#009E73"  # vert
)

theme_carte <- theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.title = element_blank(),
    legend.box = "horizontal",
    legend.text = element_text(size = 12),
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5)
  )

# -------------------------------
# 5Ô∏è‚É£ Cr√©er les cartes
# -------------------------------
carte_2001 <- ggplot(df_2001, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.85) +
  scale_color_manual(values = couleurs) +
  coord_equal() +
  theme_carte +
  labs(title = "2001")

carte_2022 <- ggplot(df_2022, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.85) +
  scale_color_manual(values = couleurs) +
  coord_equal() +
  theme_carte +
  labs(title = "2022")

# -------------------------------
# 6Ô∏è‚É£ Assembler les deux cartes
# -------------------------------
(carte_2001 + carte_2022) +
  plot_annotation(
    title = "Distribution spatiale de Carex myosuroides et Salix herbacea",
    subtitle = "Comparaison entre 2001 et 2022 dans l'√©cosyst√®me alpin de l'Aravo",
    theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
                  plot.subtitle = element_text(size = 13, hjust = 0.5))
  )
```

# Jeu de donn√©e du CBNA avec Carex at Saule





```{r}
chk.REL <- read.csv("20251019_CBNAdb_RELEVES_Carex_myosuroides.csv",row.names=1)
    chk.SIT <- read.csv("20251019_CBNAdb_SITES_Carex_myosuroides.csv")
    all.equal(rownames(chk.REL),as.character(chk.SIT$id_releve))  
    dim(chk.REL);dim(chk.SIT)
chk.REL
```

```{r}
Sal.REL <- read.csv("20251019_CBNAdb_RELEVES_Salix_herbacea.csv",row.names=1)
    Sal.SIT <- read.csv("20251019_CBNAdb_SITES_Salix_herbacea.csv")
    all.equal(rownames(chk.REL),as.character(chk.SIT$id_releve))  
    dim(chk.REL);dim(chk.SIT)
Sal.REL
```

```{r}
library(dplyr)
library(tibble)
```

```{r}
# --- V√©rification des correspondances d‚Äôidentifiants ---
all.equal(rownames(chk.REL), as.character(chk.SIT$id_releve))
all.equal(rownames(Sal.REL), as.character(Sal.SIT$id_releve))

# --- Jointure des relev√©s et des m√©tadonn√©es pour chaque esp√®ce ---
chk.full <- chk.SIT %>%
  left_join(chk.REL %>% rownames_to_column("id_releve"), by = "id_releve")

Sal.full <- Sal.SIT %>%
  left_join(Sal.REL %>% rownames_to_column("id_releve"), by = "id_releve")

# --- Filtrer les relev√©s post√©rieurs √† 1990 ---
chk.full <- chk.full %>% filter(year >= 1990)
Sal.full <- Sal.full %>% filter(year >= 1990)

# --- Identifier les relev√©s communs aux deux esp√®ces ---
releves_communs <- intersect(chk.full$id_releve, Sal.full$id_releve)

# --- Extraire les relev√©s communs ---
chk.communs <- chk.full %>% filter(id_releve %in% releves_communs)
Sal.communs <- Sal.full %>% filter(id_releve %in% releves_communs)

# --- Cr√©er une table indiquant la pr√©sence/absence des deux esp√®ces ---
Presence.combined <- full_join(
  chk.full %>% mutate(Carex_present = TRUE) %>% select(id_releve, Carex_present),
  Sal.full %>% mutate(Salix_present = TRUE) %>% select(id_releve, Salix_present),
  by = "id_releve"
) %>%
  mutate(Carex_present = ifelse(is.na(Carex_present), FALSE, Carex_present),
         Salix_present = ifelse(is.na(Salix_present), FALSE, Salix_present)) %>%
  mutate(both_species = Carex_present & Salix_present)

# --- R√©sum√© rapide ---
cat("\nNombre de relev√©s Carex post-1990 :", nrow(chk.full))
cat("\nNombre de relev√©s Salix post-1990 :", nrow(Sal.full))
cat("\nNombre de relev√©s avec les deux esp√®ces :", sum(Presence.combined$both_species))

# --- Visualiser les relev√©s communs ---
Presence.combined %>%
  filter(both_species) %>%
  head()
```











