---
title: "ARAVO"
author: "Apolline Saint-Pierre"
date: "2025-09-27"
output: html_document
---

```{r}
library(readxl)
REL2001 <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "REL2001")
View(REL2001)
library(readxl)
REL2022 <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "REL2022")
View(REL2022)
library(readxl)
META <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "META")
View(META)
```



```{r}
rel2001 = REL2001
rel2022 = REL2022
meta = META
rel2001
```

## R Markdown


```{r}
# Charger les packages
library(readxl)
library(dplyr)
library(vegan)
library(cluster)
```


```{r}
# Filtrer les ID comparables : yes/yes dans meta
valid_ids <- meta %>%
  filter(DATA_2001 == "yes" & DATA_2022 == "yes") %>%
  pull(ID)

rel2001 <- rel2001 %>% filter(ID %in% valid_ids)
rel2022 <- rel2022 %>% filter(ID %in% valid_ids)
```


```{r}
# Ajouter une colonne "Year"
rel2001$Year <- 2001
rel2022$Year <- 2022
```

```{r}
# Supprimer les colonnes non pertinentes (sommes, completed...)
rel2001_clean <- rel2001 %>%
  select(-SOMME)

rel2022_clean <- rel2022 %>%
  select(-contains("COMPLETED"), -HABITAT)
```

```{r}
# Harmoniser les noms des colonnes esp√®ces
common_species <- intersect(names(rel2001_clean), names(rel2022_clean))
meta_cols <- c("ROW","COL","ID","Year")
species_cols <- setdiff(common_species, meta_cols)

rel2001_clean <- rel2001_clean %>% select(all_of(meta_cols), all_of(species_cols))
rel2022_clean <- rel2022_clean %>% select(all_of(meta_cols), all_of(species_cols))

```


```{r}
# S'assurer que toutes les colonnes esp√®ces sont du m√™me type (numeric)
for (col in species_cols) {
  rel2001_clean[[col]] <- as.numeric(rel2001_clean[[col]])
  rel2022_clean[[col]] <- as.numeric(rel2022_clean[[col]])
}

# Supprimer les lignes contenant des NA
rel2001_clean <- rel2001_clean %>% drop_na(all_of(species_cols))
rel2022_clean <- rel2022_clean %>% drop_na(all_of(species_cols))


# Fusionner les deux jeux
all_data <- bind_rows(rel2001_clean, rel2022_clean)
all_data
```

```{r}

# Supprimer la colonne "Sol nu" si elle existe

if("Sol nu" %in% names(all_data)) {
  all_data <- all_data %>% select(-`Sol nu`)
}

# Mettre √† jour la liste des colonnes esp√®ces
species_cols_filtered <- setdiff(species_cols, "Sol nu")

# Supprimer les lignes o√π aucune esp√®ce restante n'est pr√©sente
all_data <- all_data %>% filter(rowSums(select(., all_of(species_cols_filtered))) > 0)

# Supprimer les lignes contenant des NA (s√©curit√©)
all_data <- all_data %>% drop_na(all_of(species_cols_filtered))

# Identifier ID communes
common_IDs <- intersect(rel2001_clean$ID, rel2022_clean$ID)

# Filtrer les deux jeux pour ne garder que les ID communes
rel2001_common <- rel2001_clean %>% filter(ID %in% common_IDs)
rel2022_common <- rel2022_clean %>% filter(ID %in% common_IDs)

# Fusionner
all_data_common <- bind_rows(rel2001_common, rel2022_common)

# Supprimer les NA par s√©curit√©
all_data_common <- all_data_common %>% drop_na(all_of(species_cols_filtered))
```


```{r}
all_data_common
```

```{r}

# Supprimer lignes vides
all_data_common_clean <- all_data_common %>%
  filter(rowSums(select(., all_of(species_cols_filtered))) > 0)

# --- 2. Matrice pr√©sence/absence ---
comm_matrix <- as.matrix(all_data_common_clean[, species_cols_filtered])
comm_matrix_bin <- (comm_matrix > 0) * 1


# Garder les IDs correspondant aux lignes conserv√©es
keep_rows <- rowSums(comm_matrix_bin) > 0
comm_matrix_bin <- comm_matrix_bin[keep_rows, ]
final_IDs <- all_data_common_clean$ID[keep_rows]
years <- all_data_common_clean$Year[keep_rows]

# --- 3. Calcul de la distance Jaccard ---
dist_jac <- vegdist(comm_matrix_bin, method = "jaccard")

# --- 4. Clustering hi√©rarchique ---
clust <- hclust(dist_jac, method = "ward.D2")

# Visualisation rapide
plot(clust, labels = final_IDs, main = "Dendrogramme Jaccard", hang = -1, cex = 0.8)
```
```{r}
# --- 5. Choix du nombre de clusters avec silhouette ---
k_max <- 10
sil_scores <- sapply(2:k_max, function(k) {
  cluster_assign <- cutree(clust, k)
  silhouette(cluster_assign, dist_jac) %>% summary() %>% .$avg.width
})
best_k <- which.max(sil_scores) + 1
cat("Nombre optimal de clusters selon silhouette :", best_k, "\n")

```

```{r}
# D√©couper l'arbre
cluster_assign <- cutree(clust, k = best_k)

# --- 6. Ajouter les clusters √† la table ---
all_data_common_clean <- all_data_common_clean[keep_rows, ]  # filtrer les lignes correspondant √† comm_matrix_bin
all_data_common_clean$Cluster <- cluster_assign
all_data_common_clean
```

```{r}
# --- 7. Joindre les coordonn√©es Lambert 93 depuis meta ---
# meta doit contenir : ID, X_L93, Y_L93
final_table <- all_data_common_clean %>%
  left_join(meta %>% select(ID, X_L93, Y_L93), by = "ID") %>%
  select(ID, Year, X_L93, Y_L93, Cluster)
```




```{r}
# --- 7. Joindre les coordonn√©es Lambert 93 depuis meta ---
# meta doit contenir : ID, X_L93, Y_L93
final_salix_herb <- all_data_common_clean %>%
  left_join(meta %>% select(ID, X_L93, Y_L93), by = "ID") %>%
  select(ID, Year, X_L93, Y_L93, `Care myos`, `Sali herb`)
final_salix_herb
```





```{r}
# V√©rifier le r√©sultat
head(final_table)
```
```{r}
final_table
```
```{r}
library(writexl)

# Exporter la table finale en Excel dans ton dossier ARAVO
write_xlsx(final_table, path = "final_table_clusters.xlsx")

# V√©rifier le r√©pertoire de travail (optionnel)
getwd()

```
```{r}
library(dplyr)
library(writexl)

# Calcul de la moyenne d'abondance (ou fr√©quence de pr√©sence) par cluster
species_by_cluster <- all_data_common_clean %>%
  group_by(Cluster) %>%
  summarise(across(all_of(species_cols_filtered), \(x) mean(x, na.rm = TRUE)))

```

```{r}
species_presence <- (species_by_cluster > 0) * 1
species_presence <- cbind(Cluster = species_by_cluster$Cluster, species_presence)
```

```{r}
write_xlsx(species_by_cluster, path = "species_by_cluster.xlsx")
```

```{r}
library(dplyr)
library(tidyr)
library(writexl)

# Calcul de la fr√©quence d'occurrence (% des placettes du cluster o√π l'esp√®ce est pr√©sente)
species_freq <- all_data_common_clean %>%
  group_by(Cluster) %>%
  summarise(across(all_of(species_cols_filtered),
                   \(x) 100 * sum(x > 0, na.rm = TRUE) / n()))
```

```{r}
species_freq_long <- species_freq %>%
  pivot_longer(
    -Cluster,
    names_to = "Espece",
    values_to = "Frequence"
  ) %>%
  arrange(Cluster, desc(Frequence))
```




```{r}
write_xlsx(species_freq_long, path = "species_frequence_by_cluster.xlsx")
```


```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

```


```{r}
species_freq_long <- species_freq %>%
  pivot_longer(
    -Cluster,
    names_to = "Espece",
    values_to = "Frequence"
  )
```

```{r}
ggplot(species_freq_long, aes(x = Espece, y = factor(Cluster), fill = Frequence)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "darkgreen", name = "Fr√©quence (%)") +
  labs(
    title = "Fr√©quence des esp√®ces par cluster",
    x = "Esp√®ces",
    y = "Clusters"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    panel.grid = element_blank()
  )
```

```{r}
top_species <- species_freq_long %>%
  group_by(Espece) %>%
  summarise(MaxFreq = max(Frequence)) %>%
  arrange(desc(MaxFreq)) %>%
  slice_head(n = 20) %>%
  pull(Espece)

species_freq_top <- species_freq_long %>%
  filter(Espece %in% top_species)

ggplot(species_freq_top, aes(x = Espece, y = factor(Cluster), fill = Frequence)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "darkgreen", name = "Fr√©quence (%)") +
  labs(
    title = "Top 20 esp√®ces les plus fr√©quentes par cluster",
    x = "Esp√®ces",
    y = "Clusters"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    panel.grid = element_blank()
  )
```




```{r}
# Filtrer les deux jeux pour ne garder que les ID communes
rel2001_common <- rel2001_clean %>% filter(ID %in% common_IDs)
rel2022_common <- rel2022_clean %>% filter(ID %in% common_IDs)

rel2001_common

```


```{r}
rel2022_common
```



```{r}
# -----------------------------------------------------------
# ‚öôÔ∏è Chargement des librairies n√©cessaires
# -----------------------------------------------------------
library(ade4)
library(ggplot2)
library(dplyr)

# -----------------------------------------------------------
# üß≠ V√©rification de la correspondance des lignes
# -----------------------------------------------------------
# Les ID doivent √™tre dans le m√™me ordre
all(rownames(rel2001_common) == rownames(rel2022_common))
# Si FALSE ‚Üí r√©aligner :
# rel2022_common <- rel2022_common[match(rownames(rel2001_common), rownames(rel2022_common)), ]

# -----------------------------------------------------------
# üìä 1. ACP sur chaque tableau
# -----------------------------------------------------------
# S√©lectionne uniquement les colonnes num√©riques correspondant aux esp√®ces
rel2001_common_num <- rel2001_common %>% 
  dplyr::select(-ROW, -COL, -ID, -Year)

rel2022_common_num <- rel2022_common %>% 
  dplyr::select(-ROW, -COL, -ID, -Year)


rel2001_common_num[is.na(rel2001_common_num)] <- 0
rel2022_common_num[is.na(rel2022_common_num)] <- 0


library(ade4)
# ACP pour chaque ann√©e
pca2001 <- dudi.pca(rel2001_common_num, scannf = FALSE, nf = 3)
pca2022 <- dudi.pca(rel2022_common_num, scannf = FALSE, nf = 3)

# Co-inertie
coin <- coinertia(pca2001, pca2022, scannf = FALSE)

# R√©sum√© et graphique
summary(coin)
plot(coin)

# -----------------------------------------------------------
# üîó 2. Analyse de co-inertie
# -----------------------------------------------------------
coin <- coinertia(pca2001, pca2022, scannf = FALSE)

# R√©sum√© des r√©sultats
summary(coin)

```

```{r}
# -----------------------------------------------------------
# üìà 3. Visualisations principales
# -----------------------------------------------------------
# Inertie commune

???????
# -----------------------------------------------------------
# üß† 4. Interpr√©tation
# -----------------------------------------------------------
# Coefficient RV (corr√©lation globale entre structures)
RV <- RV.rtest(pca2001$tab, pca2022$tab)
RV
plot(RV)

# -----------------------------------------------------------
# üíæ 5. Sauvegarde des coordonn√©es si besoin
# -----------------------------------------------------------
coords <- as.data.frame(coin$ls)
coords$ID <- rownames(rel2001_common)
write.csv(coords, "co_inertia_coordinates.csv", row.names = FALSE)
```



# Ici la cr√©ation de la feuille pr√©cence et absence pour salix et carex 











