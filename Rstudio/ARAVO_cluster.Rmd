---
title: "ARAVO"
author: "Apolline Saint-Pierre"
date: "2025-09-27"
output: html_document
---

```{r}

library(readxl)
REL2001 <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "REL2001")
View(REL2001)
library(readxl)
REL2022 <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "REL2022")
View(REL2022)
library(readxl)
META <- read_excel("ARAVO_RESURVEY_GRID.xlsx", 
    sheet = "META")
View(META)
```



```{r}
rel2001 = REL2001
rel2022 = REL2022
meta = META
rel2001
```

## R Markdown


```{r}
# Charger les packages
library(readxl)
library(dplyr)
library(vegan)
library(cluster)
```


```{r}
# Filtrer les ID comparables : yes/yes dans meta
valid_ids <- meta %>%
  filter(DATA_2001 == "yes" & DATA_2022 == "yes") %>%
  pull(ID)

rel2001 <- rel2001 %>% filter(ID %in% valid_ids)
rel2022 <- rel2022 %>% filter(ID %in% valid_ids)
```


```{r}
# Ajouter une colonne "Year"
rel2001$Year <- 2001
rel2022$Year <- 2022
```

```{r}
# Supprimer les colonnes non pertinentes (sommes, completed...)
rel2001_clean <- rel2001 %>%
  select(-SOMME)

rel2022_clean <- rel2022 %>%
  select(-contains("COMPLETED"), -HABITAT)
```

```{r}
# Harmoniser les noms des colonnes esp√®ces
common_species <- intersect(names(rel2001_clean), names(rel2022_clean))
meta_cols <- c("ROW","COL","ID","Year")
species_cols <- setdiff(common_species, meta_cols)

rel2001_clean <- rel2001_clean %>% select(all_of(meta_cols), all_of(species_cols))
rel2022_clean <- rel2022_clean %>% select(all_of(meta_cols), all_of(species_cols))

```


```{r}
# S'assurer que toutes les colonnes esp√®ces sont du m√™me type (numeric)
for (col in species_cols) {
  rel2001_clean[[col]] <- as.numeric(rel2001_clean[[col]])
  rel2022_clean[[col]] <- as.numeric(rel2022_clean[[col]])
}

# Supprimer les lignes contenant des NA
rel2001_clean <- rel2001_clean %>% drop_na(all_of(species_cols))
rel2022_clean <- rel2022_clean %>% drop_na(all_of(species_cols))


# Fusionner les deux jeux
all_data <- bind_rows(rel2001_clean, rel2022_clean)
all_data
```

```{r}

# Supprimer la colonne "Sol nu" si elle existe

if("Sol nu" %in% names(all_data)) {
  all_data <- all_data %>% select(-`Sol nu`)
}

# Mettre √† jour la liste des colonnes esp√®ces
species_cols_filtered <- setdiff(species_cols, "Sol nu")

# Supprimer les lignes o√π aucune esp√®ce restante n'est pr√©sente
all_data <- all_data %>% filter(rowSums(select(., all_of(species_cols_filtered))) > 0)

# Supprimer les lignes contenant des NA (s√©curit√©)
all_data <- all_data %>% drop_na(all_of(species_cols_filtered))

# Identifier ID communes
common_IDs <- intersect(rel2001_clean$ID, rel2022_clean$ID)

# Filtrer les deux jeux pour ne garder que les ID communes
rel2001_common <- rel2001_clean %>% filter(ID %in% common_IDs)
rel2022_common <- rel2022_clean %>% filter(ID %in% common_IDs)

# Fusionner
all_data_common <- bind_rows(rel2001_common, rel2022_common)

# Supprimer les NA par s√©curit√©
all_data_common <- all_data_common %>% drop_na(all_of(species_cols_filtered))
```


```{r}
all_data_common
```

```{r}

# Supprimer lignes vides
all_data_common_clean <- all_data_common %>%
  filter(rowSums(select(., all_of(species_cols_filtered))) > 0)

# --- 2. Matrice pr√©sence/absence ---
comm_matrix <- as.matrix(all_data_common_clean[, species_cols_filtered])
comm_matrix_bin <- (comm_matrix > 0) * 1


# Garder les IDs correspondant aux lignes conserv√©es
keep_rows <- rowSums(comm_matrix_bin) > 0
comm_matrix_bin <- comm_matrix_bin[keep_rows, ]
final_IDs <- all_data_common_clean$ID[keep_rows]
years <- all_data_common_clean$Year[keep_rows]

# --- 3. Calcul de la distance Jaccard ---
dist_jac <- vegdist(comm_matrix_bin, method = "jaccard")

# --- 4. Clustering hi√©rarchique ---
clust <- hclust(dist_jac, method = "ward.D2")

# Visualisation rapide
plot(clust, labels = final_IDs, main = "Dendrogramme Jaccard", hang = -1, cex = 0.8)
```
```{r}
# --- 5. Choix du nombre de clusters avec silhouette ---
k_max <- 10
sil_scores <- sapply(2:k_max, function(k) {
  cluster_assign <- cutree(clust, k)
  silhouette(cluster_assign, dist_jac) %>% summary() %>% .$avg.width
})
best_k <- which.max(sil_scores) + 1
cat("Nombre optimal de clusters selon silhouette :", best_k, "\n")

```

```{r}
# D√©couper l'arbre
cluster_assign <- cutree(clust, k = best_k)

# --- 6. Ajouter les clusters √† la table ---
all_data_common_clean <- all_data_common_clean[keep_rows, ]  # filtrer les lignes correspondant √† comm_matrix_bin
all_data_common_clean$Cluster <- cluster_assign
all_data_common_clean

``{r}
library(writexl)

# Exporter la table finale en Excel dans ton dossier ARAVO
write_xlsx(all_data_common_clean, path = "all_data_common_clean.xlsx")


```

```{r}
# --- 7. Joindre les coordonn√©es Lambert 93 depuis meta ---
# meta doit contenir : ID, X_L93, Y_L93
final_table <- all_data_common_clean %>%
  left_join(meta %>% select(ID, X_L93, Y_L93), by = "ID") %>%
  select(ID, Year, X_L93, Y_L93, Cluster)
```




```{r}
# --- 7. Joindre les coordonn√©es Lambert 93 depuis meta ---
# meta doit contenir : ID, X_L93, Y_L93
final_salix_herb <- all_data_common_clean %>%
  left_join(meta %>% select(ID, X_L93, Y_L93), by = "ID") %>%
  select(ID, Year, X_L93, Y_L93, `Care myos`, `Sali herb`)
final_salix_herb

library(writexl)

# Exporter la table finale en Excel dans ton dossier ARAVO
write_xlsx(final_salix_herb, path = "final_salix_herb.xlsx")
```





```{r}
# V√©rifier le r√©sultat
head(final_table)
```
```{r}
final_table
```
```{r}
library(writexl)

# Exporter la table finale en Excel dans ton dossier ARAVO
write_xlsx(final_table, path = "final_table_clusters.xlsx")

# V√©rifier le r√©pertoire de travail (optionnel)
getwd()

```
```{r}
library(dplyr)
library(writexl)

# Calcul de la moyenne d'abondance (ou fr√©quence de pr√©sence) par cluster
species_by_cluster <- all_data_common_clean %>%
  group_by(Cluster) %>%
  summarise(across(all_of(species_cols_filtered), \(x) mean(x, na.rm = TRUE)))

```

```{r}
species_presence <- (species_by_cluster > 0) * 1
species_presence <- cbind(Cluster = species_by_cluster$Cluster, species_presence)
```

```{r}
write_xlsx(species_by_cluster, path = "species_by_cluster.xlsx")
```

```{r}
library(dplyr)
library(tidyr)
library(writexl)

# Calcul de la fr√©quence d'occurrence (% des placettes du cluster o√π l'esp√®ce est pr√©sente)
species_freq <- all_data_common_clean %>%
  group_by(Cluster) %>%
  summarise(across(all_of(species_cols_filtered),
                   \(x) 100 * sum(x > 0, na.rm = TRUE) / n()))
```

```{r}
species_freq_long <- species_freq %>%
  pivot_longer(
    -Cluster,
    names_to = "Espece",
    values_to = "Frequence"
  ) %>%
  arrange(Cluster, desc(Frequence))
```




```{r}
write_xlsx(species_freq_long, path = "species_frequence_by_cluster.xlsx")
```


```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

```


```{r}
species_freq_long <- species_freq %>%
  pivot_longer(
    -Cluster,
    names_to = "Espece",
    values_to = "Frequence"
  )
```

```{r}
ggplot(species_freq_long, aes(x = Espece, y = factor(Cluster), fill = Frequence)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "darkgreen", name = "Fr√©quence (%)") +
  labs(
    title = "Fr√©quence des esp√®ces par cluster",
    x = "Esp√®ces",
    y = "Clusters"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    panel.grid = element_blank()
  )
```

```{r}
top_species <- species_freq_long %>%
  group_by(Espece) %>%
  summarise(MaxFreq = max(Frequence)) %>%
  arrange(desc(MaxFreq)) %>%
  slice_head(n = 20) %>%
  pull(Espece)

species_freq_top <- species_freq_long %>%
  filter(Espece %in% top_species)

ggplot(species_freq_top, aes(x = Espece, y = factor(Cluster), fill = Frequence)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "darkgreen", name = "Fr√©quence (%)") +
  labs(
    title = "Top 20 esp√®ces les plus fr√©quentes par cluster",
    x = "Esp√®ces",
    y = "Clusters"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    panel.grid = element_blank()
  )
```




```{r}
# Filtrer les deux jeux pour ne garder que les ID communes
rel2001_common <- rel2001_clean %>% filter(ID %in% common_IDs)
rel2022_common <- rel2022_clean %>% filter(ID %in% common_IDs)

rel2001_common

```


```{r}
rel2022_common
```



```{r}
# -----------------------------------------------------------
# ‚öôÔ∏è Chargement des librairies n√©cessaires
# -----------------------------------------------------------
library(ade4)
library(ggplot2)
library(dplyr)

# -----------------------------------------------------------
# üß≠ V√©rification de la correspondance des lignes
# -----------------------------------------------------------
# Les ID doivent √™tre dans le m√™me ordre
all(rownames(rel2001_common) == rownames(rel2022_common))
# Si FALSE ‚Üí r√©aligner :
# rel2022_common <- rel2022_common[match(rownames(rel2001_common), rownames(rel2022_common)), ]

# -----------------------------------------------------------
# üìä 1. ACP sur chaque tableau
# -----------------------------------------------------------
# S√©lectionne uniquement les colonnes num√©riques correspondant aux esp√®ces
rel2001_common_num <- rel2001_common %>% 
  dplyr::select(-ROW, -COL, -ID, -Year)

rel2022_common_num <- rel2022_common %>% 
  dplyr::select(-ROW, -COL, -ID, -Year)


rel2001_common_num[is.na(rel2001_common_num)] <- 0
rel2022_common_num[is.na(rel2022_common_num)] <- 0


library(ade4)
# ACP pour chaque ann√©e
pca2001 <- dudi.pca(rel2001_common_num, scannf = FALSE, nf = 3)
pca2022 <- dudi.pca(rel2022_common_num, scannf = FALSE, nf = 3)

# Co-inertie
coin <- coinertia(pca2001, pca2022, scannf = FALSE)

# R√©sum√© et graphique
summary(coin)
plot(coin)

# -----------------------------------------------------------
# üîó 2. Analyse de co-inertie
# -----------------------------------------------------------
coin <- coinertia(pca2001, pca2022, scannf = FALSE)

# R√©sum√© des r√©sultats
summary(coin)

```

```{r}
# -----------------------------------------------------------
# üìà 3. Visualisations principales
# -----------------------------------------------------------
# Inertie commune

???????
# -----------------------------------------------------------
# üß† 4. Interpr√©tation
# -----------------------------------------------------------
# Coefficient RV (corr√©lation globale entre structures)
RV <- RV.rtest(pca2001$tab, pca2022$tab)
RV
plot(RV)

# -----------------------------------------------------------
# üíæ 5. Sauvegarde des coordonn√©es si besoin
# -----------------------------------------------------------
coords <- as.data.frame(coin$ls)
coords$ID <- rownames(rel2001_common)
write.csv(coords, "co_inertia_coordinates.csv", row.names = FALSE)
```



# Ici la cr√©ation de la feuille pr√©cence et absence pour salix et carex 


```{r}
# Packages
library(tidyverse)

# On part de ton data.frame d√©j√† charg√©
df <- final_salix_herb

# Renommer pour simplifier
df <- df %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  )

# V√©rification
glimpse(df)
```

```{r}
# Table crois√©e de co-occurrence
tab <- table(df$Carex, df$Salix)
tab
```


```{r}
chisq.test(tab)
```
```{r}
fisher.test(tab)
```

```{r}
# Graphique de cooccurrence
df %>%
  count(Carex, Salix) %>%
  ggplot(aes(x = factor(Salix), y = factor(Carex), size = n, color = n)) +
  geom_point() +
  scale_size(range = c(3,10)) +
  theme_minimal() +
  labs(x = "Salix herbacea (0=abs, 1=pres)",
       y = "Carex myosuroides (0=abs, 1=pres)",
       title = "Co-occurrence des deux esp√®ces")
```


```{r}
ggplot(df, aes(x = X_L93, y = Y_L93, color = interaction(Carex, Salix))) +
  geom_point(size = 3) +
  scale_color_manual(values = c("grey50", "orange", "blue", "green"),
                     labels = c("Aucune", "Carex seule", "Salix seule", "Les deux")) +
  theme_minimal() +
  labs(title = "Distribution spatiale des co-occurrences",
       color = "Pr√©sence des esp√®ces")
```

```{r}
cor.test(df$Carex, df$Salix, method = "spearman")  # test de corr√©lation non param√©trique

```

```{r}
library(tidyverse)

df <- final_salix_herb %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  )

# V√©rification
unique(df$Year)

# ------------------------
# 2Ô∏è‚É£ Test de cooccurrence s√©par√© par ann√©e
# ------------------------

# --- Pour 2001 ---
df_2001 <- df %>% filter(Year == 2001)
tab_2001 <- table(df_2001$Carex, df_2001$Salix)
tab_2001

test_2001 <- fisher.test(tab_2001)
test_2001

# --- Pour 2022 ---
df_2022 <- df %>% filter(Year == 2022)
tab_2022 <- table(df_2022$Carex, df_2022$Salix)
tab_2022

test_2022 <- fisher.test(tab_2022)
test_2022

# ------------------------
# 3Ô∏è‚É£ R√©sum√© des r√©sultats
# ------------------------
results <- tibble(
  Year = c(2001, 2022),
  p_value = c(test_2001$p.value, test_2022$p.value),
  odds_ratio = c(test_2001$estimate, test_2022$estimate),
  CI_low = c(test_2001$conf.int[1], test_2022$conf.int[1]),
  CI_high = c(test_2001$conf.int[2], test_2022$conf.int[2])
)

print(results)
```

En 2001
L‚Äôodds ratio < 1 (0.63) sugg√®re une tendance √† l‚Äôexclusion,

üëâ mais pas significative statistiquement (p = 0.12).
Autrement dit, en 2001, Salix herbacea et Carex myosuroides pouvaient coexister dans certains plots, sans qu‚Äôon d√©tecte un sch√©ma clair d‚Äôexclusion ou d‚Äôassociation.

En 2022

L‚Äôodds ratio chute √† 0.21, et le test devient hautement significatif (p < 0.001).
Cela signifie qu‚Äôen 2022, les deux esp√®ces sont nettement moins souvent retrouv√©es ensemble qu‚Äôattendu al√©atoirement.
‚Üí Leur co-occurrence a diminu√© dans le temps.





```{r}
 1Ô∏è‚É£ Packages
# -------------------------------
library(tidyverse)
library(ggplot2)
library(patchwork)  # pour mettre deux cartes c√¥te √† c√¥te

# -------------------------------
# 2Ô∏è‚É£ Pr√©paration des donn√©es
# -------------------------------
df <- final_salix_herb %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  ) %>%
  mutate(
    combo = case_when(
      Carex == 1 & Salix == 1 ~ "Les deux",
      Carex == 1 & Salix == 0 ~ "Carex seule",
      Carex == 0 & Salix == 1 ~ "Salix seule",
      TRUE ~ "Aucune"
    )
  )

# -------------------------------
# 3Ô∏è‚É£ S√©parer les ann√©es
# -------------------------------
df_2001 <- df %>% filter(Year == 2001)
df_2022 <- df %>% filter(Year == 2022)

# -------------------------------
# 4Ô∏è‚É£ Cr√©er les cartes
# -------------------------------
carte_2001 <- ggplot(df_2001, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.8) +
  scale_color_manual(values = c("grey60", "orange", "blue", "green")) +
  theme_minimal() +
  coord_equal() +
  labs(title = "2001 - Distribution des esp√®ces",
       color = "Pr√©sence")

carte_2022 <- ggplot(df_2022, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.8) +
  scale_color_manual(values = c("grey60", "orange", "blue", "green")) +
  theme_minimal() +
  coord_equal() +
  labs(title = "2022 - Distribution des esp√®ces",
       color = "Pr√©sence")

# -------------------------------
# 5Ô∏è‚É£ Afficher c√¥te √† c√¥te
# -------------------------------
carte_2001 + carte_2022
```
```{r}
# -------------------------------
# 1Ô∏è‚É£ Packages n√©cessaires
# -------------------------------
library(tidyverse)
library(patchwork)  # pour combiner les cartes

# -------------------------------
# 2Ô∏è‚É£ Pr√©paration des donn√©es
# -------------------------------
df <- final_salix_herb %>%
  rename(
    Carex = `Care myos`,
    Salix = `Sali herb`
  ) %>%
  mutate(
    combo = case_when(
      Carex == 1 & Salix == 1 ~ "Les deux esp√®ces",
      Carex == 1 & Salix == 0 ~ "Carex seule",
      Carex == 0 & Salix == 1 ~ "Salix seule",
      TRUE ~ "Aucune des deux"
    )
  )

# -------------------------------
# 3Ô∏è‚É£ S√©parer les ann√©es
# -------------------------------
df_2001 <- df %>% filter(Year == 2001)
df_2022 <- df %>% filter(Year == 2022)

# -------------------------------
# 4Ô∏è‚É£ D√©finir les couleurs et le th√®me
# -------------------------------
couleurs <- c(
  "Aucune des deux" = "grey70",
  "Carex seule" = "#E69F00",  # orange
  "Salix seule" = "#0072B2",  # bleu
  "Les deux esp√®ces" = "#009E73"  # vert
)

theme_carte <- theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.title = element_blank(),
    legend.box = "horizontal",
    legend.text = element_text(size = 12),
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5)
  )

# -------------------------------
# 5Ô∏è‚É£ Cr√©er les cartes
# -------------------------------
carte_2001 <- ggplot(df_2001, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.85) +
  scale_color_manual(values = couleurs) +
  coord_equal() +
  theme_carte +
  labs(title = "2001")

carte_2022 <- ggplot(df_2022, aes(x = X_L93, y = Y_L93, color = combo)) +
  geom_point(size = 3, alpha = 0.85) +
  scale_color_manual(values = couleurs) +
  coord_equal() +
  theme_carte +
  labs(title = "2022")

# -------------------------------
# 6Ô∏è‚É£ Assembler les deux cartes
# -------------------------------
(carte_2001 + carte_2022) +
  plot_annotation(
    title = "Distribution spatiale de Carex myosuroides et Salix herbacea",
    subtitle = "Comparaison entre 2001 et 2022 dans l'√©cosyst√®me alpin de l'Aravo",
    theme = theme(plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
                  plot.subtitle = element_text(size = 13, hjust = 0.5))
  )
```

# Jeu de donn√©e du CBNA avec Carex at Saule



```{r}
chk.REL <- read.csv("20251019_CBNAdb_RELEVES_Carex_myosuroides.csv",row.names=1)
    chk.SIT <- read.csv("20251019_CBNAdb_SITES_Carex_myosuroides.csv")
    all.equal(rownames(chk.REL),as.character(chk.SIT$id_releve))  
    dim(chk.REL);dim(chk.SIT)
chk.REL
```

```{r}
Sal.REL <- read.csv("20251019_CBNAdb_RELEVES_Salix_herbacea.csv")
    Sal.SIT <- read.csv("20251019_CBNAdb_SITES_Salix_herbacea.csv")
    all.equal(rownames(chk.REL),as.character(chk.SIT$id_releve))  
    dim(chk.REL);dim(chk.SIT)
Sal.REL
```

```{r}
library(dplyr)
library(tibble)
```

```{r}

# --- 1. Lecture des fichiers REL et SIT ---
chk.REL <- read.csv("20251019_CBNAdb_RELEVES_Carex_myosuroides.csv", stringsAsFactors = FALSE)
chk.SIT <- read.csv("20251019_CBNAdb_SITES_Carex_myosuroides.csv", stringsAsFactors = FALSE)

Sal.REL <- read.csv("20251019_CBNAdb_RELEVES_Salix_herbacea.csv", stringsAsFactors = FALSE)
Sal.SIT <- read.csv("20251019_CBNAdb_SITES_Salix_herbacea.csv", stringsAsFactors = FALSE)

# --- 2. Renommer la colonne X (si n√©cessaire) ---
if("X" %in% names(chk.REL)) names(chk.REL)[names(chk.REL) == "X"] <- "id_releve"
if("X" %in% names(Sal.REL)) names(Sal.REL)[names(Sal.REL) == "X"] <- "id_releve"

# --- 3. Harmoniser les types d'identifiant ---
chk.REL$id_releve <- as.character(chk.REL$id_releve)
chk.SIT$id_releve <- as.character(chk.SIT$id_releve)
Sal.REL$id_releve <- as.character(Sal.REL$id_releve)
Sal.SIT$id_releve <- as.character(Sal.SIT$id_releve)

# --- 4. Fusion des relev√©s avec les m√©tadonn√©es ---
chk.full <- left_join(chk.SIT, chk.REL, by = "id_releve")
Sal.full <- left_join(Sal.SIT, Sal.REL, by = "id_releve")

# --- 5. Filtrer les relev√©s post√©rieurs √† 1990 ---
chk.full <- chk.full %>% filter(YR.REL >= 1990)
Sal.full <- Sal.full %>% filter(YR.REL >= 1990)

# --- 6. Identifier les relev√©s communs ---
releves_communs <- intersect(chk.full$id_releve, Sal.full$id_releve)

# --- 7. Extraire les relev√©s communs ---
chk.communs <- chk.full %>% filter(id_releve %in% releves_communs)
Sal.communs <- Sal.full %>% filter(id_releve %in% releves_communs)

# --- 8. Table combin√©e pr√©sence/absence des deux esp√®ces ---

Presence.combined <- full_join(
  chk.full %>% dplyr::select(id_releve) %>% dplyr::mutate(Carex_present = 1),
  Sal.full %>% dplyr::select(id_releve) %>% dplyr::mutate(Salix_present = 1),
  by = "id_releve"
) %>%
  mutate(
    Carex_present = ifelse(is.na(Carex_present), 0, Carex_present),
    Salix_present = ifelse(is.na(Salix_present), 0, Salix_present),
    both_species = ifelse(Carex_present == 1 & Salix_present == 1, 1, 0)
  )


# --- 9. R√©sum√© rapide ---
cat("\nNombre de relev√©s Carex post-1990 :", nrow(chk.full))
cat("\nNombre de relev√©s Salix post-1990 :", nrow(Sal.full))
cat("\nNombre de relev√©s avec les deux esp√®ces :", sum(Presence.combined$both_species))

# --- 10. Carte des relev√©s communs ---
# On r√©cup√®re les coordonn√©es √† partir de chk.SIT (ou Sal.SIT si pr√©f√©rence)

releves_communs_df <- Presence.combined %>%
  filter(both_species == 1) %>%   # 1 = les deux esp√®ces pr√©sentes
  left_join(chk.SIT %>% dplyr::select(id_releve, x_l93, y_l93), by = "id_releve")

ggplot(releves_communs_df, aes(x = x_l93, y = y_l93)) +
  geom_point(color = "darkgreen", size = 3) +
  theme_minimal() +
  labs(title = "Relev√©s communs Carex myosuroides & Salix herbacea",
       x = "Coordonn√©e X (L93)",
       y = "Coordonn√©e Y (L93)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# --- Optionnel : carte color√©e par ann√©e ---
releves_communs_df <- Presence.combined %>%
  filter(both_species == 1) %>%
  left_join(chk.SIT %>% dplyr::select(id_releve, x_l93, y_l93, YR.REL), by = "id_releve")
ggplot(releves_communs_df, aes(x = x_l93, y = y_l93, color = factor(YR.REL))) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Relev√©s communs Carex & Salix par ann√©e",
       x = "Coordonn√©e X (L93)",
       y = "Coordonn√©e Y (L93)",
       color = "Ann√©e") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```



```{r}
Presence.combined
```





```{r}
chk.REL
```

```{r}
chk.SIT
```


```{r}
library(dplyr)
library(ggplot2)

# Calculer le nombre de relev√©s communs par ann√©e
evolution <- Presence.combined %>%
  left_join(chk.SIT %>% dplyr::select(id_releve, YR.REL), by = "id_releve") %>%
  filter(!is.na(YR.REL)) %>%
  group_by(YR.REL) %>%
  summarise(n_communs = sum(both_species),
            n_total = n(),
            prop_communs = n_communs / n_total)

# Graphique du nombre de relev√©s communs par ann√©e
ggplot(evolution, aes(x = YR.REL, y = n_communs)) +
  geom_line(color = "darkgreen") +
  geom_point(color = "darkgreen") +
  theme_minimal() +
  labs(title = "√âvolution des relev√©s communs Carex & Salix par ann√©e",
       x = "Ann√©e",
       y = "Nombre de relev√©s communs")
```


```{r}
ggplot(evolution, aes(x = YR.REL, y = prop_communs)) +
  geom_line(color = "darkblue") +
  geom_point(color = "darkblue") +
  theme_minimal() +
  labs(title = "Proportion de relev√©s avec Carex & Salix par ann√©e",
       x = "Ann√©e",
       y = "Proportion de relev√©s communs")
```

```{r}
ggplot(evolution, aes(x = YR.REL, y = prop_communs)) +
  geom_point(color = "darkblue") +
  geom_smooth(method = "loess", color = "red") +
  theme_minimal() +
  labs(title = "Tendance des co-occurrences Carex & Salix",
       x = "Ann√©e",
       y = "Proportion de relev√©s communs")
```

```{r}
library(dplyr)
library(ggplot2)

# --- Cr√©er une table avec les ann√©es et pr√©sence des esp√®ces ---
evolution_full <- Presence.combined %>%
  left_join(chk.SIT %>% dplyr::select(id_releve, YR.REL), by = "id_releve") %>%
  filter(!is.na(YR.REL)) %>%
  group_by(YR.REL) %>%
  summarise(
    n_carex_only = sum(Carex_present == 1 & Salix_present == 0),
    n_salix_only = sum(Carex_present == 0 & Salix_present == 1),
    n_both = sum(both_species == 1)
  ) %>%
  tidyr::pivot_longer(
    cols = c(n_carex_only, n_salix_only, n_both),
    names_to = "type",
    values_to = "count"
  )

# --- Visualisation ---
ggplot(evolution_full, aes(x = YR.REL, y = count, color = type)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  theme_minimal() +
  scale_color_manual(
    values = c("n_carex_only" = "green", "n_salix_only" = "blue", "n_both" = "red"),
    labels = c("Carex seul", "Salix seul", "Les deux esp√®ces")
  ) +
  labs(
    title = "√âvolution des relev√©s Carex, Salix et communs par ann√©e",
    x = "Ann√©e",
    y = "Nombre de relev√©s",
    color = "Type de relev√©"
  ) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
```
# V√©rification des effectifs par an 

```{r}
library(dplyr)
library(ggplot2)

# --- V√©rifier le nombre de relev√©s par ann√©e ---
releves_par_an <- Presence.combined %>%
  left_join(chk.SIT %>% dplyr::select(id_releve, YR.REL), by = "id_releve") %>%
  count(YR.REL)

# --- Visualisation ---
ggplot(releves_par_an, aes(x = YR.REL, y = n)) +
  geom_col(fill = "steelblue") +
  theme_minimal() +
  labs(
    title = "Nombre de relev√©s par ann√©e",
    x = "Ann√©e",
    y = "Nombre de relev√©s"
  )
```

```{r}
ggplot(chk.SIT, aes(x = x_l93, y = y_l93, color = as.factor(YR.REL))) +
  geom_point() +
  theme_minimal() +
  labs(title = "R√©partition spatiale des relev√©s au fil du temps",
       x = "X L93", y = "Y L93", color = "Ann√©e")
```



```{r}
library(dplyr)

# --- Ajouter les altitudes et ann√©es Carex et Salix dans Presence.combined ---
Presence.combined <- Presence.combined %>%
  left_join(
    chk.SIT %>%
      dplyr::select(id_releve, ELEV, YR.REL) %>%
      rename(ELEV_carex = ELEV, YEAR_carex = YR.REL),
    by = "id_releve"
  ) %>%
  left_join(
    Sal.SIT %>%
      dplyr::select(id_releve, ELEV, YR.REL) %>%
      rename(ELEV_salix = ELEV, YEAR_salix = YR.REL),
    by = "id_releve"
  )
```


```{r}
library(dplyr)

# --- 1. Identifier les id communs entre les deux jeux de donn√©es ---
intersect_ids <- intersect(chk.SIT$id_releve, Sal.SIT$id_releve)
cat("Nombre de relev√©s communs :", length(intersect_ids), "\n")


# --- Red√©finir les s√©lections avec dplyr::select() explicite pour √©viter les conflits ---
compare_sites <- chk.SIT %>%
  dplyr::filter(id_releve %in% intersect_ids) %>%
  dplyr::select(id_releve, ELEV, YR.REL, x_l93, y_l93) %>%
  dplyr::left_join(
    Sal.SIT %>%
      dplyr::select(id_releve, ELEV, YR.REL, x_l93, y_l93),
    by = "id_releve",
    suffix = c("_carex", "_salix")
  )

# --- V√©rification des diff√©rences ---
nb_diff_elev <- sum(compare_sites$ELEV_carex != compare_sites$ELEV_salix, na.rm = TRUE)
nb_diff_year <- sum(compare_sites$YR.REL_carex != compare_sites$YR.REL_salix, na.rm = TRUE)

cat("Diff√©rences d'altitude :", nb_diff_elev, "\n")
cat("Diff√©rences d'ann√©e :", nb_diff_year, "\n")
# --- 3. V√©rification des diff√©rences ---
nb_diff_elev <- sum(compare_sites$ELEV_carex != compare_sites$ELEV_salix, na.rm = TRUE)
nb_diff_year <- sum(compare_sites$YR.REL_carex != compare_sites$YR.REL_salix, na.rm = TRUE)

cat("Diff√©rences d'altitude :", nb_diff_elev, "\n")
cat("Diff√©rences d'ann√©e :", nb_diff_year, "\n")

```

```{r}
Presence.combined <- Presence.combined %>%
  mutate(
    ELEV = coalesce(ELEV_carex, ELEV_salix),
    YR.REL = coalesce(YEAR_carex, YEAR_salix)
  )
```

```{r}
glm_carex <- glm(Carex_present ~ ELEV + YR.REL, data = Presence.combined, family = binomial)
glm_salix <- glm(Salix_present ~ ELEV + YR.REL, data = Presence.combined, family = binomial)

summary(glm_carex)
summary(glm_salix)
```
```{r}
overdisp_fun <- function(model) {
  rdf <- df.residual(model)
  rp <- residuals(model, type = "pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq / rdf
  pval <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
  c(chisq = Pearson.chisq, ratio = prat, rdf = rdf, p = pval)
}

overdisp_fun(glm_carex)
overdisp_fun(glm_salix)
```

```{r}
exp(coef(glm_carex))
exp(coef(glm_salix))
```



```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# --- 1. Mod√®les GLM pour chaque esp√®ce ---
glm_carex <- glm(Carex_present ~ ELEV, data = Presence.combined, family = binomial)
glm_salix <- glm(Salix_present ~ ELEV, data = Presence.combined, family = binomial)

# --- 2. Cr√©ation du jeu de donn√©es pour pr√©dictions ---
newdata <- data.frame(ELEV = seq(min(Presence.combined$ELEV, na.rm = TRUE),
                                 max(Presence.combined$ELEV, na.rm = TRUE),
                                 length.out = 200))

newdata$Carex_pred <- predict(glm_carex, newdata = newdata, type = "response")
newdata$Salix_pred <- predict(glm_salix, newdata = newdata, type = "response")

# --- 3. Mise en forme longue pour ggplot ---
pred_df <- newdata %>%
  tidyr::pivot_longer(cols = c(Carex_pred, Salix_pred),
                      names_to = "Species",
                      values_to = "Probability") %>%
  mutate(Species = dplyr::recode(Species,
                                 "Carex_pred" = "Carex myosuroides",
                                 "Salix_pred" = "Salix herbacea"))

# --- 4. Visualisation ---
ggplot(pred_df, aes(x = ELEV, y = Probability, color = Species)) +
  geom_line(size = 1.3) +
  geom_point(data = Presence.combined %>%
               tidyr::pivot_longer(cols = c(Carex_present, Salix_present),
                                   names_to = "Species",
                                   values_to = "Presence") %>%
               mutate(Species = dplyr::recode(Species,
                                              "Carex_present" = "Carex myosuroides",
                                              "Salix_present" = "Salix herbacea")),
             aes(x = ELEV, y = Presence),
             alpha = 0.2, size = 1) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Effet de l'altitude sur la probabilit√© de pr√©sence",
    subtitle = "Mod√®le logistique binomial",
    x = "Altitude (m)",
    y = "Probabilit√© de pr√©sence",
    color = "Esp√®ce"
  ) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    legend.position = "top"
  )
```

```{r}
Presence.combined
```

























